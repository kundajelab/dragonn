from __future__ import absolute_import, division, print_function
from . import util, pwm, fileProcessing as fp
import argparse
import numpy as np
import random
import math
from collections import OrderedDict
import json
import re


class LabelGenerator(object):

    def __init__(self, labelNames, labelsFromGeneratedSequenceFunction):
        """
            labelNames: an array of strings
            labelsFromGeneratedSequenceFunction: function that accepts
                an instance of generatedSequence and returns an array
                of the labels
        """
        self.labelNames = labelNames
        self.labelsFromGeneratedSequenceFunction = labelsFromGeneratedSequenceFunction

    def generateLabels(self, generatedSequence):
        return self.labelsFromGeneratedSequenceFunction(
            self, generatedSequence)


class IsInTraceLabelGenerator(LabelGenerator):

    def __init__(self, labelNames):
        def labelsFromGeneratedSequenceFunction(self, generatedSequence):
            return [(1 if generatedSequence.additionalInfo.isInTrace(x) else 0)
                    for x in self.labelNames]
        super(IsInTraceLabelGenerator, self).__init__(
            labelNames, labelsFromGeneratedSequenceFunction)


def printSequences(outputFileName, sequenceSetGenerator, includeEmbeddings=False, labelGenerator=None, includeFasta=False):
    """
        outputFileName: string
        sequenceSetGenerator: instance of AbstractSequenceSetGenerator
        Given an output filename, and an instance of AbstractSequenceSetGenerator,
        will call the sequence set generator and print the generated sequences
        to the output file. Will also create a file "info_outputFileName.txt"
        in the samedirectory as outputFileName that contains all the information
        about sequenceSetGenerator.
        includeEmbeddings: a boolean indicating whether to print a column that lists the embeddings
        labelGenerator: instance of LabelGenerator
    """
    ofh = fp.getFileHandle(outputFileName, 'w')
    fastaOfh = fp.getFileHandle(fp.getFileNameParts(
        outputFileName).getFilePathWithTransformation(lambda x: x, extension=".fa"), 'w')
    ofh.write("seqName\tsequence" + ("\tembeddings" if includeEmbeddings else "") + ("\t" +
                                                                                     "\t".join(labelGenerator.labelNames) if labelGenerator is not None else "") + "\n")
    generatedSequences = sequenceSetGenerator.generateSequences()  # returns a generator
    for generatedSequence in generatedSequences:
        ofh.write(generatedSequence.seqName + "\t" + generatedSequence.seq
                  + ("\t" + ",".join(str(x)
                                     for x in generatedSequence.embeddings) if includeEmbeddings else "")
                  + ("\t" + "\t".join(str(x) for x in labelGenerator.generateLabels(
                      generatedSequence)) if labelGenerator is not None else "")
                  + "\n")
        fastaOfh.write(">" + generatedSequence.seqName + "\n")
        fastaOfh.write(generatedSequence.seq + "\n")

    ofh.close()
    fastaOfh.close()
    infoFilePath = fp.getFileNameParts(outputFileName).getFilePathWithTransformation(
        lambda x: x + "_info", extension=".txt")

    ofh = fp.getFileHandle(infoFilePath, 'w')
    ofh.write(util.formattedJsonDump(sequenceSetGenerator.getJsonableObject()))
    ofh.close()


def printSequencesTransformationPosNeg(outputFileNamePos, outputFileNameNeg, sequenceSetGenerator, transformation):
    """
        outputFileName: string
        sequenceSetGenerator: instance of AbstractSequenceSetGenerator
                generatedSequences: the sequences that have been generated by sequenceSetGenerator
        Given an output filename, and an instance of AbstractSequenceSetGenerator,
        will print the generated sequences to the output file. Will also create a file
                "info_outputFileName.txt" in the same directory as outputFileName that contains all the
                information about sequenceSetGenerator.
    """
    ofhPos = fp.getFileHandle(outputFileNamePos, 'w')
    ofhPos.write("seqName\tsequence\n")
    ofhNeg = fp.getFileHandle(outputFileNameNeg, 'w')
    ofhNeg.write("seqName\tsequence\n")
    generatedSequences = sequenceSetGenerator.generateSequences()  # returns a generator

    for generateSequence in generatedSequences:
                # Iterate through the generated sequences, recording them in
                # the pos. file, make a 1 bp substitution in the motif, and
                # record the changed sequence in the neg. file
        ofhPos.write(generateSequence.seqName + "\t" +
                     generateSequence.seq + "\n")

        embedding = generateSequence.embeddings[0]
        embeddingList = list(embedding.what)
        transformation.transform(embeddingList)
        embeddingNeg = ''.join(embeddingList)
        seqNeg = generateSequence.seq[0:embedding.startPos] + embeddingNeg + generateSequence.seq[
            embedding.startPos + len(embeddingNeg):len(generateSequence.seq)]
        generateSequenceNeg = generateSequence
        generateSequenceNeg.seq = seqNeg
        ofhNeg.write(generateSequenceNeg.seqName + "\t" +
                     generateSequenceNeg.seq + "\n")

    ofhPos.close()
    ofhNeg.close()
    infoFilePathPos = fp.getFileNameParts(outputFileNamePos).getFilePathWithTransformation(
        lambda x: "info_" + x, extension=".txt")

    import json
    ofhPos = fp.getFileHandle(infoFilePathPos, 'w')
    ofhPos.write(json.dumps(sequenceSetGenerator.getJsonableObject(),
                            indent=4, separators=(',', ': ')))
    ofhPos.close()


class DefaultNameMixin(object):

    def __init__(self, name):
        if (name == None):
            name = self.getDefaultName()
        self.name = name

    def getDefaultName(self):
        return json.dumps(self.getJsonableObject())


class AbstractPositionGenerator(DefaultNameMixin):
    """
        Given the length of the background sequence and the length
        of the substring you are trying to embed, will return a start position
        to embed the substring at.
    """

    def generatePos(self, lenBackground, lenSubstring, additionalInfo=None):
        if (additionalInfo is not None):
            additionalInfo.updateTrace(self.name)
        return self._generatePos(lenBackground, lenSubstring, additionalInfo)

    def _generatePos(self, lenBackground, lenSubstring, additionalInfo):
        raise NotImplementedError()

    def getJsonableObject(self):
        raise NotImplementedError()


class UniformPositionGenerator(AbstractPositionGenerator):
    """
        samples a start position to embed the substring in uniformly at random;
        does not return positions that are too close to the end of the
        background sequence to embed the full substring.
    """

    def __init__(self, name=None):
        super(UniformPositionGenerator, self).__init__(name)

    def _generatePos(self, lenBackground, lenSubstring, additionalInfo):
        return sampleIndexWithinRegionOfLength(lenBackground, lenSubstring)

    def getJsonableObject(self):
        return "uniform"
uniformPositionGenerator = UniformPositionGenerator()


class InsideCentralBp(AbstractPositionGenerator):
    """
        returns a position within the central region of a background
        sequence, sampled uniformly at random
    """

    def __init__(self, centralBp, name=None):
        """
            centralBp: the number of bp, centered in the middle of the background,
            from which to sample the position. Is NOT +/- centralBp around the
            middle (is +/- centralBp/2 around the middle).
            If the background sequence is even and centralBp is odd, the shorter
            region will go on the left.
        """
        self.centralBp = centralBp
        super(InsideCentralBp, self).__init__(name)

    def _generatePos(self, lenBackground, lenSubstring, additionalInfo):
        if (lenBackground < self.centralBp):
            raise RuntimeError("The background length should be atleast as long as self.centralBp; is " +
                               str(lenBackground) + " and " + str(self.centralBp) + " respectively")
        startIndexForRegionToEmbedIn = int(
            lenBackground / 2) - int(self.centralBp / 2)
        indexToSample = startIndexForRegionToEmbedIn + \
            sampleIndexWithinRegionOfLength(self.centralBp, lenSubstring)
        return int(indexToSample)

    def getJsonableObject(self):
        return "insideCentral-" + str(self.centralBp)


class OutsideCentralBp(AbstractPositionGenerator):
    """
        Returns a position OUTSIDE the central region of a background sequence,
        sampled uniformly at random. Complement of InsideCentralBp.
    """

    def __init__(self, centralBp, name=None):
        self.centralBp = centralBp
        super(OutsideCentralBp, self).__init__(name)

    def _generatePos(self, lenBackground, lenSubstring, additionalInfo):
        # choose whether to embed in the left or the right
        if random.random() > 0.5:
            left = True
        else:
            left = False
        # embeddableLength is the length of the region we are considering
        # embedding in
        embeddableLength = 0.5 * (lenBackground - self.centralBp)
        # if lenBackground-self.centralBp is odd, the longer region
        # goes on the left (inverse of the shorter embeddable region going on the left in
        # the centralBpToEmbedIn case
        if (left):
            embeddableLength = math.ceil(embeddableLength)
            startIndexForRegionToEmbedIn = 0
        else:
            embeddableLength = math.floor(embeddableLength)
            startIndexForRegionToEmbedIn = math.ceil(
                (lenBackground - self.centralBp) / 2) + self.centralBp
        indexToSample = startIndexForRegionToEmbedIn + \
            sampleIndexWithinRegionOfLength(embeddableLength, lenSubstring)
        return int(indexToSample)

    def getJsonableObject(self):
        return "outsideCentral-" + str(self.centralBp)


class GeneratedSequence(object):
    """
        An object representing a sequence that has been
        generated.
    """

    def __init__(self, seqName, seq, embeddings, additionalInfo):
        """
            seqName: string
            seq: generated sequence (string)
            embeddings: array of Embedding objects
            additionalInfo: instance of AdditionalInfo
        """
        self.seqName = seqName
        self.seq = seq
        self.embeddings = embeddings
        self.additionalInfo = additionalInfo


class Embedding(object):
    """
        Represents something that has been embedded in
        a sequence
    """

    def __init__(self, what, startPos):
        """
            what: object representing the thing that has been embedded. Should have __str__ and __len__ defined
            startPos: that position relative to the start of the
            parent sequence at which seq has been embedded
        """
        self.what = what
        self.startPos = startPos

    def __str__(self):
        return "pos-" + str(self.startPos) + "_" + str(self.what)

    @classmethod
    def fromString(cls, string, whatClass=None):
        if (whatClass is None):
            whatClass = StringEmbeddable
        # was printed out as pos-[startPos]_[what], but the
        #[what] may contain underscores, hence the maxsplit
        # to avoid splitting on them.
        prefix, startPos, whatString = re.split("-|_", string, maxsplit=2)
        return cls(what=whatClass.fromString(whatString), startPos=startPos)


def getEmbeddingsFromString(string):
    if len(string) == 0:
        return []
    else:
        embeddingStrings = string.split(",")
        return [Embedding.fromString(x) for x in embeddingStrings]


class AbstractSequenceSetGenerator(object):
    """
        class that is used to return a generator for a collection
        of generated sequences.
    """

    def generateSequences(self):
        """
            returns a generator of GeneratedSequence objects
        """
        raise NotImplementedError()

    def getJsonableObject(self):
        """
            returns an object representing the details of this, which
            can be converted to json.
        """
        raise NotImplementedError()


class GenerateSequenceNTimes(AbstractSequenceSetGenerator):
    """
        If you just want to use a generator of a single sequence and
        call it N times, use this class.
    """

    def __init__(self, singleSetGenerator, N):
        """
            singleSetGenerator: an instance of AbstractSequenceSetGenerator
        """
        self.singleSetGenerator = singleSetGenerator
        self.N = N

    def generateSequences(self):
        """
            calls singleSetGenerator N times.
        """
        for i in range(self.N):
            yield self.singleSetGenerator.generateSequence()

    def getJsonableObject(self):
        return OrderedDict([("numSeq", self.N), ("singleSetGenerator", self.singleSetGenerator.getJsonableObject())])


class AbstractSingleSequenceGenerator(object):
    """
        When called, generates a single sequence
    """

    def __init__(self, namePrefix=None):
        """
            namePrefix: the GeneratedSequence object has a field for the object's name; this is
            the prefix associated with that name. The suffix is the value of a counter that
            is incremented every time
        """
        self.namePrefix = namePrefix if namePrefix is not None else "synth"
        self.sequenceCounter = 0

    def generateSequence(self):
        """
            returns GeneratedSequence object
        """
        raise NotImplementedError()

    def getJsonableObject(self):
        """
            returns an object representing the details of this, which
            can be converted to json.
        """
        raise NotImplementedError()


class AdditionalInfo(object):

    def __init__(self):
        self.trace = OrderedDict()  # a trace of everything that was called.
        self.additionalInfo = OrderedDict()  # for more ad-hoc messages

    def isInTrace(self, operatorName):
        return operatorName in self.trace

    def updateTrace(self, operatorName):
        if (operatorName not in self.trace):
            self.trace[operatorName] = 0
        self.trace[operatorName] += 1

    def updateAdditionalInfo(self, operatorName, value):
        self.additionaInfo[operatorName] = value


class EmbedInABackground(AbstractSingleSequenceGenerator):
    """
        Takes a backgroundGenerator and a series of embedders. Will
        generate the background and then call each of the embedders in
        succession. Then returns the result.
    """

    def __init__(self, backgroundGenerator, embedders, namePrefix=None):
        """
            backgroundGenerator: instance of AbstractBackgroundGenerator
            embedders: array of instances of AbstractEmbedder
            namePrefix: see parent
        """
        super(EmbedInABackground, self).__init__(namePrefix)
        self.backgroundGenerator = backgroundGenerator
        self.embedders = embedders

    def generateSequence(self):
        """
            generates a background using self.backgroundGenerator, splits it into an array,
            and passes it to each of self.embedders in turn for embedding things.
            returns an instance of GeneratedSequence
        """
        additionalInfo = AdditionalInfo()
        backgroundString = self.backgroundGenerator.generateBackground()
        backgroundStringArr = [x for x in backgroundString]
        # priorEmbeddedThings keeps track of what has already been embedded
        priorEmbeddedThings = PriorEmbeddedThings_numpyArrayBacked(
            len(backgroundStringArr))
        for embedder in self.embedders:
            embedder.embed(backgroundStringArr,
                           priorEmbeddedThings, additionalInfo)
        self.sequenceCounter += 1
        return GeneratedSequence(self.namePrefix + str(self.sequenceCounter), "".join(backgroundStringArr), priorEmbeddedThings.getEmbeddings(), additionalInfo)

    def getJsonableObject(self):
        """
            see parent
        """
        return OrderedDict([("class", "EmbedInABackground"), ("namePrefix", self.namePrefix), ("backgroundGenerator", self.backgroundGenerator.getJsonableObject()), ("embedders", [x.getJsonableObject() for x in self.embedders])
                            ])


class AbstractPriorEmbeddedThings(object):
    """
        class that is used to keep track of what has already been embedded in a sequence
    """

    def canEmbed(self, startPos, endPos):
        """
            returns a boolean indicating whether the region from startPos to endPos is available for embedding
        """
        raise NotImplementedError()

    def addEmbedding(self, startPos, what):
        """
            embeds "what" from startPos to startPos+len(what). Creates an Embedding object
        """
        raise NotImplementedError()

    def getNumOccupiedPos(self):
        """
            returns the number of posiitons that are filled with some kind of embedding
        """
        raise NotImplementedError()

    def getTotalPos(self):
        """
            returns the total number of positions available to embed things in
        """
        raise NotImplementedError()

    def getEmbeddings(self):
        """
            returns a collection of Embedding objects
        """
        raise NotImplementedError()


class PriorEmbeddedThings_numpyArrayBacked(AbstractPriorEmbeddedThings):
    """
        uses a numpy array where positions are set to 1 if they are occupied,
        to determin which positions are occupied and which are not.
        See parent for more documentation.
    """

    def __init__(self, seqLen):
        """
            seqLen: integer indicating length of the sequence you are embedding in
        """
        self.seqLen = seqLen
        self.arr = np.zeros(seqLen)
        self.embeddings = []

    def canEmbed(self, startPos, endPos):
        return np.sum(self.arr[startPos:endPos]) == 0

    def addEmbedding(self, startPos, what):
        """
            what: instance of Embeddable
        """
        self.arr[startPos:startPos + len(what)] = 1
        self.embeddings.append(Embedding(what=what, startPos=startPos))

    def getNumOccupiedPos(self):
        return np.sum(self.arr)

    def getTotalPos(self):
        return len(self.arr)

    def getEmbeddings(self):
        return self.embeddings


class AbstractEmbeddable(object):
    """
        Represents a thing which can be embedded. Note that
        an Embeddable + a position = an embedding.
    """

    def __len__(self):
        raise NotImplementedError()

    def __str__(self):
        raise NotImplementedError()

    def getDescription(self):
        raise NotImplementedError()

    def canEmbed(self, priorEmbeddedThings, startPos):
        """
            priorEmbeddedThings: instance of AbstractPriorEmbeddedThings
            startPos: the position you are considering embedding self at
            returns a boolean indicating whether self can be embedded at startPos,
                given the things that have already been embedded.
        """
        raise NotImplementedError()

    def embedInBackgroundStringArr(self, priorEmbeddedThings, backgroundStringArr, startPos):
        """
            Will embed self at startPos in backgroundStringArr, and will update priorEmbeddedThings.
            priorEmbeddedThings: instance of AbstractPriorEmbeddedThings
            backgroundStringArr: an array of characters representing the background
            startPos: the position to embed self at
        """
        raise NotImplementedError()


class StringEmbeddable(AbstractEmbeddable):
    """
        represents a string (such as a sampling from a pwm) that is to
        be embedded in a background. See docs for superclass.
    """

    def __init__(self, string, stringDescription=""):
        self.string = string
        self.stringDescription = stringDescription

    def __len__(self):
        return len(self.string)

    def __str__(self):
        return self.stringDescription + ("-" if self.stringDescription != "" else "") + self.string

    def getDescription(self):
        return self.stringDescription

    def canEmbed(self, priorEmbeddedThings, startPos):
        return priorEmbeddedThings.canEmbed(startPos, startPos + len(self.string))

    def embedInBackgroundStringArr(self, priorEmbeddedThings, backgroundStringArr, startPos):
        backgroundStringArr[startPos:startPos + len(self.string)] = self.string
        priorEmbeddedThings.addEmbedding(startPos, self)

    @classmethod
    def fromString(cls, theString):
        if ("-" in theString):
            stringDescription, coreString = theString.split("-")
            return cls(string=coreString, stringDescription=stringDescription)
        else:
            return cls(string=theString)


class PairEmbeddable_General(AbstractEmbeddable):
    """
        embeds two Embeddable objects with some sep
    """

    def __init__(self, embeddable1, embeddable2, separation, embeddableDescription, nothingInBetween=True):
        self.embeddable1 = embeddable1
        self.embeddable2 = embeddable2
        self.separation = separation
        self.embeddableDescription = embeddableDescription
        self.nothingInBetween = nothingInBetween

    def __len__(self):
        return len(self.embeddable1) + self.separation + len(self.embeddable2)

    def __str__(self):
        return self.embeddableDescription + ("-" if embeddableDescription != "" else "") + str(self.embeddable1) + "-Gap" + str(self.separation) + "-" + str(self.embeddable2)

    def getDescription(self):
        return self.embeddableDescription

    def canEmbed(self, priorEmbeddedThings, startPos):
        if (self.nothingInBetween):
            return priorEmbeddedThings.canEmbed(startPos, startPos + len(self))
        else:
            return (priorEmbeddedThings.canEmbed(startPos, startPos + len(self.embeddable1))
                    and priorEmbeddedThings.canEmbed(startPos + len(self.embeddable1) + self.separation, startPos + len(self)))

    def embedInBackgroundStringArr(self, priorEmbeddedThings, backgroundStringArr, startPos):
        self.embeddable1.embedInBackgroundStringArr(
            priorEmbeddedThings, backgroundStringArr, startPos)
        self.embeddable2.embedInBackgroundStringArr(
            priorEmbeddedThings, backgroundStringArr, startPos + self.separation)
        if (self.nothingInBetween):
            priorEmbeddedThings.addEmbedding(startPos, self)
        else:
            priorEmbeddedThings.addEmbedding(startPos, self.embeddable1)
            priorEmbeddedThings.addEmbedding(
                startPos + len(self.string1) + self.separation, self.embeddable2)


class PairEmbeddable(AbstractEmbeddable):
    """
        Represents a pair of strings that are embedded with some separation.
        Used for motif grammars. See superclass docs.
    """

    def __init__(self, string1, string2, separation, embeddableDescription, nothingInBetween=True):
        """
            separation: int of positions separating
                string1 and string2
            nothingInBetween: if true, then nothing else is allowed to be
                embedded in the gap between string1 and string2.
        """
        self.string1 = string1
        self.string2 = string2
        self.separation = separation
        self.embeddableDescription = embeddableDescription
        self.nothingInBetween = nothingInBetween

    def __len__(self):
        return len(self.string1) + self.separation + len(self.string2)

    def __str__(self):
        return self.embeddableDescription + "-" + self.string1 + "-Gap" + str(self.separation) + "-" + self.string2

    def getDescription(self):
        return self.embeddableDescription

    def canEmbed(self, priorEmbeddedThings, startPos):
        if (self.nothingInBetween):
            return priorEmbeddedThings.canEmbed(startPos, startPos + len(self))
        else:
            return (priorEmbeddedThings.canEmbed(startPos, startPos + len(self.string1))
                    and priorEmbeddedThings.canEmbed(startPos + len(self.string1) + self.separation, startPos + len(self)))

    def embedInBackgroundStringArr(self, priorEmbeddedThings, backgroundStringArr, startPos):
        backgroundStringArr[startPos:startPos +
                            len(self.string1)] = self.string1
        backgroundStringArr[
            startPos + len(self.string1) + self.separation:startPos + len(self)] = self.string2
        if (self.nothingInBetween):
            priorEmbeddedThings.addEmbedding(startPos, self)
        else:
            priorEmbeddedThings.addEmbedding(startPos, self.string1)
            priorEmbeddedThings.addEmbedding(
                startPos + len(self.string1) + self.separation, self.string2)


class AbstractEmbedder(DefaultNameMixin):
    """
        class that is used to embed things in a sequence
    """

    def embed(self, backgroundStringArr, priorEmbeddedThings, additionalInfo=None):
        """
            backgroundStringArr: array of characters representing the background string
            priorEmbeddedThings: instance of AbstractPriorEmbeddedThings.
            additionalInfo: instance of AdditionalInfo; allows the embedder to send back info about what it did
            modifies: backgroundStringArr to include whatever this class has embedded
        """
        if (additionalInfo is not None):
            additionalInfo.updateTrace(self.name)
        return self._embed(backgroundStringArr, priorEmbeddedThings, additionalInfo)

    def _embed(self, backgroundStringArr, priorEmbeddedThings, additionalInfo):
        raise NotImplementedError()

    def getJsonableObject(self):
        raise NotImplementedError()


class EmbeddableEmbedder(AbstractEmbedder):
    """
        Embeds instances of AbstractEmbeddable within the background sequence,
        at a position sampled from a distribution. Only embeds at unoccupied
        positions
    """

    def __init__(self, embeddableGenerator, positionGenerator=uniformPositionGenerator, name=None):
        """
            embeddableGenerator: instance of AbstractEmbeddableGenerator
            positionGenerator: instance of AbstractPositionGenerator
        """
        self.embeddableGenerator = embeddableGenerator
        self.positionGenerator = positionGenerator
        super(EmbeddableEmbedder, self).__init__(name)

    def _embed(self, backgroundStringArr, priorEmbeddedThings, additionalInfo):
        """
            calls self.embeddableGenerator to determine the embeddable to embed. Then
            calls self.positionGenerator to determine the start position at which
            to embed it. If the position is occupied, will resample from
            self.positionGenerator. Will warn if tries to resample too many times.
        """
        embeddable = self.embeddableGenerator.generateEmbeddable()
        canEmbed = False
        tries = 0
        while canEmbed == False:
            tries += 1
            startPos = self.positionGenerator.generatePos(
                len(backgroundStringArr), len(embeddable), additionalInfo)
            canEmbed = embeddable.canEmbed(priorEmbeddedThings, startPos)
            if (tries % 10 == 0):
                print("Warning: made " + str(tries) + " at trying to embed " + str(embeddable) + " in region of length " + str(
                    priorEmbeddedThings.getTotalPos()) + " with " + str(priorEmbeddedThings.getNumOccupiedPos()) + " occupied sites")
        embeddable.embedInBackgroundStringArr(
            priorEmbeddedThings, backgroundStringArr, startPos)

    def getJsonableObject(self):
        return OrderedDict([("embeddableGenerator", self.embeddableGenerator.getJsonableObject()), ("positionGenerator", self.positionGenerator.getJsonableObject())])


class XOREmbedder(AbstractEmbedder):
    """
        calls exactly one of the supplied embedders
    """

    def __init__(self, embedder1, embedder2, probOfFirst, name=None):
        """
            embedder1 & embedder2: instances of AbstractEmbedder
            probOfFirst: probability of calling the first embedder
        """
        self.embedder1 = embedder1
        self.embedder2 = embedder2
        self.probOfFirst = probOfFirst
        super(XOREmbedder, self).__init__(name)

    def _embed(self, backgroundStringArr, priorEmbeddedThings, additionalInfo):
        if (random.random() < self.probOfFirst):
            embedder = self.embedder1
        else:
            embedder = self.embedder2
        return embedder.embed(backgroundStringArr, priorEmbeddedThings, additionalInfo)

    def getJsonableObject(self):
        return OrderedDict([("class", "XOREmbedder"), ("embedder1", self.embedder1.getJsonableObject()), ("embedder2", self.embedder2.getJsonableObject()), ("probOfFirst", self.probOfFirst)])


class AllEmbedders(AbstractEmbedder):
    """
        Wrapper around a list of embedders to make sure all are called
        Useful in conjunciton with RandomSubsetOfEmbedders
    """

    def __init__(self, embedders, name=None):
        self.embedders = embedders
        super(AllEmbedders, self).__init__(name)

    def _embed(self, backgroundStringArr, priorEmbeddedThings, additionalInfo):
        for embedder in self.embedders:
            embedder.embed(backgroundStringArr,
                           priorEmbeddedThings, additionalInfo)

    def getJsonableObject(self):
        return OrderedDict([("class", "AllEmbedders"), ("embedders", [x.getJsonableObject() for x in self.embedders])
                            ])


class RandomSubsetOfEmbedders(AbstractEmbedder):
    """
        Takes a quantity generator that generates a quantity of
        embedders, and executes that many embedders from a supplied set,
        in sequence
    """

    def __init__(self, quantityGenerator, embedders, name=None):
        """
            quantityGenerator: instance of AbstractQuantityGenerator
        """
        if (isinstance(quantityGenerator, int)):
            quantityGenerator = FixedQuantityGenerator(quantityGenerator)
        assert isinstance(quantityGenerator, AbstractQuantityGenerator)
        self.quantityGenerator = quantityGenerator
        self.embedders = embedders
        super(RandomSubsetOfEmbedders, self).__init__(name)

    def _embed(self, backgroundStringArr, priorEmbeddedThings, additionalInfo):
        numberOfEmbeddersToSample = self.quantityGenerator.generateQuantity()
        if (numberOfEmbeddersToSample > len(self.embedders)):
            raise RuntimeError("numberOfEmbeddersToSample came up as " + str(
                numberOfEmbeddersToSample) + " but total number of embedders is " + str(len(self.embedders)))
        sampledEmbedders = util.sampleWithoutReplacement(
            self.embedders, numberOfEmbeddersToSample)
        for embedder in sampledEmbedders:
            embedder.embed(backgroundStringArr,
                           priorEmbeddedThings, additionalInfo)

    def getJsonableObject(self):
        return OrderedDict([("class", "RandomSubsetOfEmbedders"), ("setOfEmbedders", [x.getJsonableObject() for x in self.embedders])])


class RepeatedEmbedder(AbstractEmbedder):
    """
        Wrapper around an embedder to call it multiple times according to sampling
        from a distribution.
    """

    def __init__(self, embedder, quantityGenerator, name=None):
        """
            embedder: instance of AbstractEmbedder
            quantityGenerator: instance of AbstractQuantityGenerator
        """
        self.embedder = embedder
        self.quantityGenerator = quantityGenerator
        super(RepeatedEmbedder, self).__init__(name)

    def _embed(self, backgroundStringArr, priorEmbeddedThings, additionalInfo):
        """
            first calls self.quantityGenerator.generateQuantity(), then calls
            self.embedder a number of times equal to the value returned.
        """
        quantity = self.quantityGenerator.generateQuantity()
        for i in range(quantity):
            self.embedder.embed(backgroundStringArr,
                                priorEmbeddedThings, additionalInfo)

    def getJsonableObject(self):
        return OrderedDict([("class", "RepeatedEmbedder"), ("embedder", self.embedder.getJsonableObject()), ("quantityGenerator", self.quantityGenerator.getJsonableObject())])


class AbstractQuantityGenerator(DefaultNameMixin):
    """
        class to sample according to a distribution
    """

    def generateQuantity(self):
        """
            returns the sampled value
        """
        raise NotImplementedError()

    def getJsonableObject(self):
        raise NotImplementedError()


class ChooseValueFromASet(AbstractQuantityGenerator):
    """
        Randomly samples a particular value from a set of values
    """

    def __init__(self, setOfPossibleValues, name=None):
        self.setOfPossibleValues = setOfPossibleValues
        super(ChooseValueFromASet, self).__init__(name)

    def generateQuantity(self):
        return self.setOfPossibleValues[int(random.random() * (len(self.setOfPossibleValues)))]

    def getJsonableObject(self):
        return OrderedDict([("class", "ChooseValueFromASet"), ("possibleValues", self.setOfPossibleValues)])


class UniformIntegerGenerator(AbstractQuantityGenerator):
    """
        Randomly samples an integer from minVal to maxVal, inclusive.
    """

    def __init__(self, minVal, maxVal, name=None):
        self.minVal = minVal
        self.maxVal = maxVal
        super(UniformIntegerGenerator, self).__init__(name)

    def generateQuantity(self):
        # the 1+ makes the max val inclusive
        return self.minVal + int(random.random() * (1 + self.maxVal - self.minVal))

    def getJsonableObject(self):
        return OrderedDict([("class", "UniformIntegerGenerator"), ("minVal", self.minVal), ("maxVal", self.maxVal)])


class FixedQuantityGenerator(AbstractQuantityGenerator):
    """
        returns a fixed number every time generateQuantity is called
    """

    def __init__(self, quantity, name=None):
        """
            quantity: the value to return when generateQuantity is called.
        """
        self.quantity = quantity
        super(FixedQuantityGenerator, self).__init__(name)

    def generateQuantity(self):
        return self.quantity

    def getJsonableObject(self):
        return "fixedQuantity-" + str(self.quantity)


class PoissonQuantityGenerator(AbstractQuantityGenerator):
    """
        Generates values according to a poisson distribution
    """

    def __init__(self, mean, name=None):
        """
            mean: the mean of the poisson distribution
        """
        self.mean = mean
        super(PoissonQuantityGenerator, self).__init__(name)

    def generateQuantity(self):
        return np.random.poisson(self.mean)

    def getJsonableObject(self):
        return "poisson-" + str(self.mean)


class BernoulliQuantityGenerator(AbstractQuantityGenerator):
    """
        Generates 1 or 0 according to a bernoulli distribution
    """

    def __init__(self, prob, name=None):
        """
            prob: probability of 1
        """
        self.prob = prob
        super(BernoulliQuantityGenerator, self).__init__(name)

    def generateQuantity(self):
        return 1 if (np.random.random() <= self.prob) else 0

    def getJsonableObject(self):
        return "bernoulli-" + str(self.prob)


class MinMaxWrapper(AbstractQuantityGenerator):
    """
        Wrapper that restricts a distribution to only return values between the min and
        the max. If a value outside the range is returned, resamples until
        it obtains a value within the range. Warns if it resamples too many times.
    """

    def __init__(self, quantityGenerator, theMin=None, theMax=None, name=None):
        """
            quantityGenerator: samples from the distribution to truncate
            theMin: can be None; if so will be ignored
            theMax: can be None; if so will be ignored.
        """
        self.quantityGenerator = quantityGenerator
        self.theMin = theMin
        self.theMax = theMax
        assert self.quantityGenerator is not None
        super(MinMaxWrapper, self).__init__(name)

    def generateQuantity(self):
        tries = 0
        while (True):
            tries += 1
            quantity = self.quantityGenerator.generateQuantity()
            if ((self.theMin is None or quantity >= self.theMin) and (self.theMax is None or quantity <= self.theMax)):
                return quantity
            if (tries % 10 == 0):
                print("warning: made " + str(tries) +
                      " tries at trying to sample from distribution with min/max limits")

    def getJsonableObject(self):
        return OrderedDict([("min", self.theMin), ("max", self.theMax), ("quantityGenerator", self.quantityGenerator.getJsonableObject())])


class ZeroInflater(AbstractQuantityGenerator):
    """
        Wrapper that inflates the number of zeros returned. Flips a coin; if positive,
        will return zero - otherwise will sample from the wrapped distribution (which may still return 0)
    """

    def __init__(self, quantityGenerator, zeroProb, name=None):
        """
            quantityGenerator: the distribution to sample from with probability 1-zeroProb
            zeroProb: the probability of just returning 0 without sampling from quantityGenerator
        """
        self.quantityGenerator = quantityGenerator
        self.zeroProb = zeroProb
        super(ZeroInflater, self).__init__(name)

    def generateQuantity(self):
        val = random.random()
        if (val < self.zeroProb):
            return 0
        else:
            return self.quantityGenerator.generateQuantity()

    def getJsonableObject(self):
        return OrderedDict([("class", "ZeroInflater"), ("zeroProb", self.zeroProb), ("quantityGenerator", self.quantityGenerator.getJsonableObject())])


class SubstringEmbedder(EmbeddableEmbedder):
    """
        embeds a single generated substring within the background sequence,
        at a position sampled from a distribution. Only embeds at unoccupied
        positions
    """

    def __init__(self, substringGenerator, positionGenerator=uniformPositionGenerator, name=None):
        """
            substringGenerator: instance of AbstractSubstringGenerator
            positionGenerator: instance of AbstractPositionGenerator
        """
        super(SubstringEmbedder, self).__init__(
            SubstringEmbeddableGenerator(substringGenerator), positionGenerator, name)


def sampleIndexWithinRegionOfLength(length, lengthOfThingToEmbed):
    """
        uniformly at random samples integers from 0 to length-lengthOfThingToEmbedIn
    """
    assert lengthOfThingToEmbed <= length
    indexToSample = int(
        random.random() * ((length - lengthOfThingToEmbed) + 1))
    return indexToSample


class AbstractEmbeddableGenerator(DefaultNameMixin):
    """
        Generates an embeddable, usually for embedding in a background sequence.
    """

    def generateEmbeddable(self):
        raise NotImplementedError()

    def getJsonableObject(self):
        raise NotImplementedError()


class PairEmbeddableGenerator_General(AbstractEmbeddableGenerator):

    def __init__(self, embeddableGenerator1, embeddableGenerator2, separationGenerator, name=None):
        self.embeddableGenerator1 = embeddableGenerator1
        self.embeddableGenerator2 = embeddableGenerator2
        self.separationGenerator = separationGenerator
        super(PairEmbeddableGenerator, self).__init__(name)

    def generateEmbeddable(self):
        embeddable1 = self.embeddableGenerator1.generateEmbeddable()
        embeddable2 = self.embeddableGenerator2.generateEmbeddable()
        return PairEmbeddable(
            embeddable1, embeddable2, self.separationGenerator.generateQuantity(
            ), embeddable1.getDescription() + "+" + embeddable2.getDescription()
        )

    def getJsonableObject(self):
        return OrderedDict([("class", "PairEmbeddableGenerator"), ("embeddableGenerator1", self.embeddableGenerator1.getJsonableObject()), ("embeddableenerator2", self.embeddableGenerator2.getJsonableObject()), ("separationGenerator", self.separationGenerator.getJsonableObject())
                            ])


class PairEmbeddableGenerator(AbstractEmbeddableGenerator):

    def __init__(self, substringGenerator1, substringGenerator2, separationGenerator, name=None):
        """
            Specifically for a pair of substrings
            substringGenerator1: instance of AbstractSubstringGenerator
            substringGenerator2: instance of AbstractSubstringGenerator
            separationGenerator: instance of AbstractQuantityGenerator
        """
        self.substringGenerator1 = substringGenerator1
        self.substringGenerator2 = substringGenerator2
        self.separationGenerator = separationGenerator
        super(PairEmbeddableGenerator, self).__init__(name)

    def generateEmbeddable(self):
        string1, string1Description = self.substringGenerator1.generateSubstring()
        string2, string2Description = self.substringGenerator2.generateSubstring()
        return PairEmbeddable(
            string1, string2, self.separationGenerator.generateQuantity(), string1Description +
            "+" + string2Description
        )

    def getJsonableObject(self):
        return OrderedDict([("class", "PairEmbeddableGenerator"), ("substringGenerator1", self.substringGenerator1.getJsonableObject()), ("substringGenerator2", self.substringGenerator2.getJsonableObject()), ("separationGenerator", self.separationGenerator.getJsonableObject())
                            ])


class SubstringEmbeddableGenerator(AbstractEmbeddableGenerator):

    def __init__(self, substringGenerator, name=None):
        """
            substringGenerator: instance of AbstractSubstringGenerator
        """
        self.substringGenerator = substringGenerator
        super(SubstringEmbeddableGenerator, self).__init__(name)

    def generateEmbeddable(self):
        substring, substringDescription = self.substringGenerator.generateSubstring()
        return StringEmbeddable(substring, substringDescription)

    def getJsonableObject(self):
        return OrderedDict([("class", "SubstringEmbeddableGenerator"), ("substringGenerator", self.substringGenerator.getJsonableObject())])


class AbstractSubstringGenerator(DefaultNameMixin):
    """
        Generates a substring, usually for embedding in a background sequence.
    """

    def generateSubstring(self):
        raise NotImplementedError()

    def getJsonableObject(self):
        raise NotImplementedError()


class FixedSubstringGenerator(AbstractSubstringGenerator):
    """
        When generateSubstring() is called, always returns the same string.
        The string also serves as its own description
    """

    def __init__(self, fixedSubstring, name=None):
        self.fixedSubstring = fixedSubstring
        super(FixedSubstringGenerator, self).__init__(name)

    def generateSubstring(self):
        return self.fixedSubstring, self.fixedSubstring

    def getJsonableObject(self):
        return "fixedSubstring-" + self.fixedSubstring


class TransformedSubstringGenerator(AbstractSubstringGenerator):
    """
        Takes a substringGenerator and a set of AbstractTransformation objects,
        applies the transformations to the generated substring
    """

    def __init__(self, substringGenerator, transformations, transformationsDescription="transformations", name=None):
        self.substringGenerator = substringGenerator
        self.transformations = transformations
        self.transformationsDescription = transformationsDescription
        super(TransformedSubstringGenerator, self).__init__(self.name)

    def generateSubstring(self):
        substring, substringDescription = self.substringGenerator.generateSubstring()
        baseSubstringArr = [x for x in substring]
        for transformation in self.transformations:
            baseSubstringArr = transformation.transform(baseSubstringArr)
        return "".join(baseSubstringArr), self.transformationsDescription + "-" + substringDescription

    def getJsonableObject(self):
        return OrderedDict([("class", "TransformedSubstringGenerator"), ("substringGenerator", self.substringGenerator.getJsonableObject()), ("transformations", [x.getJsonableObject() for x in self.transformations])])


class AbstractTransformation(DefaultNameMixin):
    """
        takes an array of characters, applies some transformation, returns an
        array of characters (may be the same (mutated) one or a different one)
    """

    def transform(self, stringArr):
        """
            stringArr is an array of characters.
            Returns an array of characters that has the transformation applied.
            May mutate stringArr
        """
        raise NotImplementedError()

    def getJsonableObject(self):
        raise NotImplementedError()


class RevertToReference(AbstractTransformation):
    """
        for a series of mutations, reverts the supplied string to the reference
        ("unmutated") string
    """

    def __init__(self, setOfMutations, name=None):
        """
            setOfMutations: instance of AbstractSetOfMutations
        """
        self.setOfMutations = setOfMutations
        super(RevertToReference, self).__init__(name)

    def transform(self, stringArr):  # see parent docs
        for mutation in self.setOfMutations.getMutationsArr():
            mutation.revert(stringArr)
        return stringArr

    def getJsonableObject(self):
        return OrderedDict([("class", "RevertToReference"), ("setOfMutations", self.setOfMutations.getJsonableObject())])


class AbstractApplySingleMutationFromSet(AbstractTransformation):
    """
        Class for applying a single mutation from a set of mutations; used
        to transform substrings generated by another method
    """

    def __init__(self, setOfMutations, name=None):
        """
            setOfMutations: instance of AbstractSetOfMutations
        """
        self.setOfMutations = setOfMutations
        super(AbstractApplySingleMutationFromSet, self).__init__(name)

    def transform(self, stringArr):  # see parent docs
        selectedMutation = self.selectMutation()
        selectedMutation.applyMutation(stringArr)
        return stringArr

    def selectMutation(self):
        raise NotImplementedError()

    def getClassName(self):
        raise NotImplementedError()

    def getJsonableObject(self):
        return OrderedDict([("class", self.getClassName()), ("selectedMutations", self.setOfMutations.getJsonableObject())])


class ChooseMutationAtRandom(AbstractApplySingleMutationFromSet):
    """
        Selects a mutation at random from self.setOfMutations to apply; see parent docs.
    """

    def selectMutation(self):
        mutationsArr = self.setOfMutations.getMutationsArr()
        return mutationsArr[int(random.random() * len(mutationsArr))]

    def getClassName(self):
        return "ChooseMutationAtRandom"


class AbstractSetOfMutations(object):
    """
        Represents a collection of pwm.Mutation objects
    """

    def __init__(self, mutationsArr):
        """
            mutationsArr: array of pwm.Mutation objects
        """
        self.mutationsArr = mutationsArr

    def getMutationsArr(self):
        return self.mutationsArr

    def getJsonableObject(self):
        raise NotImplementedError()


class TopNMutationsFromPwmRelativeToBestHit(AbstractSetOfMutations):
    """
        See docs for parent; here, the collection of mutations are the
        top N strongest mutations for a PWM as compared to the best
        match for that pwm.
    """

    def __init__(self, pwm, N, bestHitMode):
        """
            pwm: instance of pwm.PWM
            N: the N in the top N strongest mutations
            bestHitMode: one of pwm.BEST_HIT_MODE; pwm.BEST_HIT_MODE.pwmProb defines the
                topN mutations relative to the probability matrix of the pwm, while
                pwm.BEST_HIT_MODE.logOdds defines the topN mutations relative to the log
                odds matrix computed using the background frequency specified in the
                pwm object.
        """
        self.pwm = pwm
        self.N = N
        self.bestHitMode = bestHitMode
        mutationsArr = self.pwm.computeSingleBpMutationEffects(
            self.bestHitMode)
        super(TopNMutationsFromPwmRelativeToBestHit,
              self).__init__(mutationsArr)

    def getJsonableObject(self):
        return OrderedDict([("class", "TopNMutationsFromPwmRelativeToBestHit"), ("pwm", self.pwm.name), ('N', self.N), ("bestHitMode", self.bestHitMode)])

# is an AbstractSetOfMutations object


class TopNMutationsFromPwmRelativeToBestHit_FromLoadedMotifs(TopNMutationsFromPwmRelativeToBestHit):
    """
        Like parent, except extracts the pwm.PWM object from an AbstractLoadedMotifs object,
        saving you a few lines of code.
    """

    def __init__(self, loadedMotifs, pwmName, N, bestHitMode):
        self.loadedMotifs = loadedMotifs
        super(TopNMutationsFromPwmRelativeToBestHit_FromLoadedMotifs, self).__init__(
            self.loadedMotifs.getPwm(pwmName), N, bestHitMode)

    def getJsonableObject(self):
        obj = super(
            TopNMutationsFromPwmRelativeToBestHit_FromLoadedMotifs, self).getJsonableObject()
        obj['loadedMotifs'] = self.loadedMotifs.getJsonableObject()
        return obj


class ReverseComplementWrapper(AbstractSubstringGenerator):
    """
        Wrapper around a AbstractSubstringGenerator that reverse complements it
        with the specified probability.
    """

    def __init__(self, substringGenerator, reverseComplementProb=0.5, name=None):
        """
            substringGenerator: instance of AbstractSubstringGenerator
            reverseComplementProb: probability of reverse complementing it.
        """
        self.reverseComplementProb = reverseComplementProb
        self.substringGenerator = substringGenerator
        super(ReverseComplementWrapper, self).__init__(name)

    def generateSubstring(self):
        seq, seqDescription = self.substringGenerator.generateSubstring()
        if (random.random() < self.reverseComplementProb):
            seq = util.reverseComplement(seq)
            seqDescription = "revComp-" + seqDescription
        return seq, seqDescription

    def getJsonableObject(self):
        return OrderedDict([("class", "ReverseComplementWrapper"), ("reverseComplementProb", self.reverseComplementProb), ("substringGenerator", self.substringGenerator.getJsonableObject())])


class PwmSampler(AbstractSubstringGenerator):
    """
        samples from the pwm by calling self.pwm.sampleFromPwm
    """

    def __init__(self, pwm, name=None):
        self.pwm = pwm
        super(PwmSampler, self).__init__(name)

    def generateSubstring(self):
        return self.pwm.sampleFromPwm()[0], self.pwm.name

    def getJsonableObject(self):
        return OrderedDict([("class", "PwmSampler"), ("motifName", self.pwm.name)])


class PwmSamplerFromLoadedMotifs(PwmSampler):
    """
        convenience wrapper class for instantiating parent by pulling the pwm given the name
        from an AbstractLoadedMotifs object (it basically extracts the pwm for you)
    """

    def __init__(self, loadedMotifs, motifName, name=None):
        self.loadedMotifs = loadedMotifs
        super(PwmSamplerFromLoadedMotifs, self).__init__(
            loadedMotifs.getPwm(motifName), name)

    def getJsonableObject(self):
        obj = super(PwmSamplerFromLoadedMotifs, self).getJsonableObject()
        obj['loadedMotifs'] = self.loadedMotifs.getJsonableObject()
        return obj


class BestHitPwm(AbstractSubstringGenerator):
    """
        always returns the best possible match to the pwm in question when called
    """

    def __init__(self, pwm, bestHitMode=pwm.BEST_HIT_MODE.pwmProb, name=None):
        self.pwm = pwm
        self.bestHitMode = bestHitMode
        super(BestHitPwm, self).__init__(name)

    def generateSubstring(self):
        return self.pwm.getBestHit(self.bestHitMode), self.pwm.name

    def getJsonableObject(self):
        return OrderedDict([("class", "BestHitPwm"), ("pwm", self.pwm.name), ("bestHitMode", self.bestHitMode)])


class BestHitPwmFromLoadedMotifs(BestHitPwm):
    """
        convenience wrapper class for instantiating parent by pulling the pwm given the name
        from an AbstractLoadedMotifs object (it basically extracts the pwm for you)
    """

    def __init__(self, loadedMotifs, motifName, bestHitMode=pwm.BEST_HIT_MODE.pwmProb, name=None):
        self.loadedMotifs = loadedMotifs
        super(BestHitPwmFromLoadedMotifs, self).__init__(
            loadedMotifs.getPwm(motifName), bestHitMode, name)

    def getJsonableObject(self):
        obj = super(BestHitPwmFromLoadedMotifs, self).getJsonableObject()
        obj['loadedMotifs'] = self.loadedMotifs.getJsonableObject()
        return obj


class AbstractLoadedMotifs(object):
    """
        A class that contains instances of pwm.PWM loaded from a file.
        The pwms can be accessed by name.
    """

    def __init__(self, fileName, pseudocountProb=0.0, background=util.DEFAULT_BACKGROUND_FREQ):
        """
            fileName: the path to the file to laod
            pseudocountProb: if some of the pwms have 0 probability for
            some of the positions, will add the specified pseudocountProb
            to the rows of the pwm and renormalise.
        """
        self.fileName = fileName
        fileHandle = fp.getFileHandle(fileName)
        self.pseudocountProb = pseudocountProb
        self.background = background
        self.recordedPwms = OrderedDict()
        action = self.getReadPwmAction(self.recordedPwms)
        fp.performActionOnEachLineOfFile(
            fileHandle=fileHandle, transformation=fp.trimNewline, action=action
        )
        for pwm in self.recordedPwms.values():
            pwm.finalise(pseudocountProb=self.pseudocountProb)

    def getPwm(self, name):
        """
            returns the pwm.PWM instance with the specified name.
        """
        return self.recordedPwms[name]

    def getReadPwmAction(self, recordedPwms):
        """
            This is the action that is to be performed on each line of the
            file when it is read in. recordedPwms is an OrderedDict that
            stores instances of pwm.PWM
        """
        raise NotImplementedError()

    def getJsonableObject(self):
        return OrderedDict([("fileName", self.fileName), ("pseudocountProb", self.pseudocountProb), ("background", self.background)])


class LoadedEncodeMotifs(AbstractLoadedMotifs):
    """
        This class is specifically for reading files in the encode motif
        format - specifically the motifs.txt file that contains Pouya's motifs
    """

    def getReadPwmAction(self, recordedPwms):
        currentPwm = util.VariableWrapper(None)

        def action(inp, lineNumber):
            if (inp.startswith(">")):
                inp = inp.lstrip(">")
                inpArr = inp.split()
                motifName = inpArr[0]
                currentPwm.var = pwm.PWM(motifName, background=self.background)
                recordedPwms[currentPwm.var.name] = currentPwm.var
            else:
                # assume that it's a line of the pwm
                assert currentPwm.var is not None
                inpArr = inp.split()
                summaryLetter = inpArr[0]
                currentPwm.var.addRow([float(x) for x in inpArr[1:]])
        return action


class AbstractBackgroundGenerator(object):
    """
        Returns the sequence that the embeddings are subsequently inserted into.
    """

    def generateBackground(self):
        raise NotImplementedError()

    def getJsonableObject(self):
        raise NotImplementedError()


class RepeatedSubstringBackgroundGenerator(AbstractBackgroundGenerator):

    def __init__(self, substringGenerator, repetitions):
        """
            substringGenerator: instance of AbstractSubstringGenerator
            repetitions: instance of AbstractQuantityGenerator. If pass an int,
                will create a FixedQuantityGenerator from the int.
            returns the concatenation of all the calls to the substringGenerator
        """
        self.substringGenerator = substringGenerator
        if isinstance(repetitions, int):
            self.repetitions = FixedQuantityGenerator(repetitions)
        else:
            assert isinstance(repetitions, AbstractQuantityGenerator)
            self.repetitions = repetitions

    def generateBackground(self):
        toReturn = []
        for i in range(self.repetitions.generateQuantity()):
            # first pos is substring, second pos is the name
            toReturn.append(self.substringGenerator.generateSubstring()[0])
        return "".join(toReturn)

    def getJsonableObject(self):
        return OrderedDict([("class", "RepeatedSubstringBackgroundGenerator"), ("substringGenerator", self.substringGenerator.getJsonableObject()), ("repetitions", self.repetitions.getJsonableObject())])


class SampleFromDiscreteDistributionSubstringGenerator(AbstractSubstringGenerator):

    def __init__(self, discreteDistribution):
        """
            discreteDistribution: instance of util.DiscreteDistribution
        """
        self.discreteDistribution = discreteDistribution

    def generateSubstring(self):
        return util.sampleFromDiscreteDistribution(self.discreteDistribution)

    def getJsonableObject(self):
        return OrderedDict([("class", "SampleFromDiscreteDistributionSubstringGenerator"), ("discreteDistribution", self.discreteDistribution.valToFreq)])


class ZeroOrderBackgroundGenerator(RepeatedSubstringBackgroundGenerator):
    """
        returns a sequence with 40% GC content. Each base is sampled independently.
    """

    def __init__(self, seqLength, discreteDistribution=util.DEFAULT_BASE_DISCRETE_DISTRIBUTION):
        """
            seqLength: the length of the sequence to return. Can also be an instance of AbstractQuantityGenerator
            discreteDistribution: instance of util.DiscreteDistribution
        """
        super(ZeroOrderBackgroundGenerator, self).__init__(
            SampleFromDiscreteDistributionSubstringGenerator(discreteDistribution), seqLength)

###
# Older API below...this was just set up to generate the background sequence
###


def getGenerationOption(string):  # for yaml serialisation
    return util.getFromEnum(GENERATION_OPTION, "GENERATION_OPTION", string)
GENERATION_OPTION = util.enum(zeroOrderMarkov="zrOrdMrkv")


def getFileNamePieceFromOptions(options):
    return options.generationOption + "_seqLen" + str(options.seqLength)


def generateString_zeroOrderMarkov(length, discreteDistribution=util.DEFAULT_BASE_DISCRETE_DISTRIBUTION):
    """
        discreteDistribution: instance of util.DiscreteDistribution
    """
    sampledArr = util.sampleNinstancesFromDiscreteDistribution(
        length, discreteDistribution)
    return "".join(sampledArr)


def generateString(options):
    if options.generationOption == GENERATION_OPTION.zeroOrderMarkov:
        return generateString_zeroOrderMarkov(length=options.seqLength)
    else:
        raise RuntimeError("Unsupported generation option: " +
                           str(options.generationOption))


def getParentArgparse():
    parser = argparse.ArgumentParser(add_help=False)
    parser.add_argument(
        "--generationOption", default=GENERATION_OPTION.zeroOrderMarkov, choices=GENERATION_OPTION.vals)
    parser.add_argument("--seqLength", type=int, required=True,
                        help="Length of the sequence to generate")
    return parser

if __name__ == "__main__":
    parser = argparse.ArgumentParser(parents=[getParentArgparse()])
    parser.add_argument("--numSamples", type=int, required=True)
    options = parser.parse_args()

    outputFileName = getFileNamePieceFromOptions(
        options) + "_numSamples-" + str(options.numSamples) + ".txt"

    outputFileHandle = open(outputFileName, 'w')
    outputFileHandle.write("id\tsequence\n")
    for i in range(options.numSamples):
        outputFileHandle.write("synthNeg" + str(i) +
                               "\t" + generateString(options) + "\n")
    outputFileHandle.close()
